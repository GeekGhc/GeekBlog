---
title: Git在开发中基本应用
date: 2016-10-14
categories:
  - Tools
tags:
    - git
    - version controller
    - plugin
---
Git版本管理在实际开发应用中对代码管理是一个非常且必备的技能 无论是对于个人开发还是团队开发都是一个值得学习的管理方案

### 前言
`Git`作为一个版本管理工具 对于程序员来说应该是相当熟悉 无论是对于个人开发者还是对于团队的开发都是必不可少的工具和技能

就比如这个`jekyll`比博客系统也是通过`Git`部署到`Github`上的 对于代码管理国内国外都有比较好的平台和服务

当然最为广泛肯定就是`Github`了 国内的话`Coding`的用户也是很多的 无论是对于哪个平台 满足我们的需求的就是最好的

### Git安装配置
Git的安装的话其实网上找到自己的环境 下载之后安装就行了

1.基本配置
安装完成后我们需要去进行简单的配置 在终端执行
```shell
$ git config
```
我们可以看到下面的几个`flag`
- --global
- --system
- --local

其实这三个也就是对应着3个不同的层级吧 对于用户,系统,具体项目  

当然我们在自己的开发环境中当然是配置--global`主要就是对我们当然的用户而言 是一个全局性的配置

接着我们配置一下我们的`user.name` 和`user.email`这个我们就用我们Github账号的用户名和邮箱
```shell
$ git config --global user.name "JellyBean"
```
这里的用户名填写自己的用户名就行了

接着就是配置`user.email`：
```shell
$ git config --global user.email = "gehuachun@outlook.coom"
```
这里还是填写你自己邮箱账户就可以了

你也可以去查看自己的用户名和邮箱
```shell
$ git config --global user.name
```
这个时候应该就是你之前配置的用户名了

当然其实我们所配置的信息 你也可以直接去`Home`目录下查看(Windows环境也是一样 因为我们是配置的是global)
```shell
$ cat ~/.gitconfig
```
这个时候你就可以看到刚才你所配置的具体的信息了

这个配置文件里面就是对`git`的具体的配置 其实对于`Git`的配置还有很多 具体的等遇到什么样的需求

如果说是对每一个项目的配置 我们在进入项目中执行
```shell
$ git init
```
我们就可以在生成的**.git**目录下的`config`里面看到对于这个项目的`git`的具体配置

### Git的基本管理流程
在我们开发一个项目时 我们可以在项目里
```shell
$ git init
```
初始化项目的`git`管理 这样就会在项目里生成对应的**.git**目录 而里面就是具体的配置

在一开始我们可以在`Github`上新建一个项目仓库 然后我们就可以进行之后的代码上传部署

而在上传之前 我们得明白`Git`的工作流程

首先我们并不是一次性就提交我们的代码 这边其实可以分成三块 一个就是我们工作的项目块 也就是存放我们编写的代码

在中间会有一个类似**缓存区**这样的一个区域块 最后才是最后提交的一个`HEAD`区域 这里就是你最后提交的结果 只有在这个里面才能提交到远程仓库中

开始时我们可以去创建一个文件
```shell
$ echo "<?php phpinfo();" >> index.php
```
这里我们生成了一个`index.php`的文件
我们去查看一下git状态

```shell
$ git status
```

我们就可以看到`git`会提示我们有一个文件需要进行跟踪 因为我们还没有加入到缓存区

所以开始我们可以去将代码加入到缓存区
```shell
$ git add .
```
在执行完毕之后我们再去执行`git status` 就看到已经没有之前的提示 说明`git`已经跟踪我们刚才所添加的`index.php`文件了

这里的`git add .`是将目录下的所有文件全都加入到缓冲区 `.`起到一个通配符的作用 当然也有`*` 例如我们需要将src目录下的php文件写入缓存区
```shell
$ git add src/*.php
```
接下来就是写入到`HEAD`区域块中
```shell
$ git commit -m "first commit"
```
这个也就可以将文件放入到`HEAD`区域块中 之后我们才可以进行文件上传提交
在提交之前我们需要去加入我们的远程仓库的 这个在创建远程仓库的时候就可以看到

所以这个时候我们就可以提交文件
```shell
$ git push origin master
```

> 如果不想要每次提交都需要输入密码的话 可以去生成一个`ssh key`这个对于`Github`和`Coding`都是一样的
>
> 包括我们在自己的**服务器**上去部署代码的时候我们也是可以去在服务器里生成对应的`key`这样加入到`Github`后我们就可以直接提交而不用输入密码了

其实大概的基本流程就是这样

### .gitignore说明
在创建远程仓库时会有这个选择 当然对于每个项目的创建这个`.gitignore`是不同的 我们自己也可以进行相应的配置

他的作用明义上就是忽略掉不必要的文件 这里的不必要并不是真的不必要

这些文件就是包含一些敏感信息数据的文件 比如`Laravel`中的`.env`文件 因为里面包含了很多开发者的私密数据 这些肯定不会暴露给别的人

还有的就是我们可以通过`npm install`去下载的包文件 以及通过`gulp`去生成的文件 因为这些文件我们完全可以在部署的时候去生成

不然的话整个项目就太繁重了 上传的效率也不是很高 而且显得很没有必要

### Git分支的应用
首先提出这样的一个场景:

我们在项目里面已经上线了部分的功能 我们正在开发其他的功能板块 这个时候你发现自己原先的项目里面出现了一个很明显的`Bug`

如果这个时候我们去修复这个`Bug`我们正在开发的功能板块还没有完成所以这个时候我们是不能推送我们的代码的

> 这个时候的矛盾就是我们需要去修复之前项目里的`Bug`但是我们又不好把半成品的功能板块推送上去

所以这个时候我们在开发我们新的功能板块时 需要去创建新的分支
```shell
$ git branch new-branch
```
这里我们就创建了一个新的分支`new-branch` 我们可以通过执行命令查看
```shell
$ git branch
```
这样就会罗列出当前项目里面所有的分支了
我们看到的`matser`就是当前分支 因为它前面会有一个*号

创建好了分支 我们可以进入我们的分支
```shell
$ git checkout new-branch
```
这样我们就可以进入到刚生成的分支里了 当然我们在创分支时 可以创建并进入该分支
```shell
$ git checkout -b new-branch
```

> 这个其实就是上面两个步骤的结合

其实这里的分支可以这么理解 就是你上线了项目的部分功能 已经投入使用

那么在线下 你需要去添加新的功能板块时就去创建一个分支 在这个新的分支里去实现功能代码逻辑

一旦之前已经上线的项目出现了`Bug`那么你s首先在新的分支里去提交增加的文件 然后切换到`master`分支去修复`Bug`而不会影响到新的分支
因为新的分支里正在实现新的功能板块还没有完成 并且已经`commit`了

修复完`Bug`后你就可以去提交以完成当前项目的**Bug修复**这个不会推送新分支里的代码
之后你完成了新的功能再将新的分支**合并**到`master`分支 这样再一起推送到远程仓库

这样就不会出现问题了 即使之前的项目出现`Bug`我们也可以在不影响正在开发的新的功能板块

我们可以去在命令行执行
```shell
$ git log
```
我们会发现只有master分支下的提交信息 而不会有新分支下的提交信息

在完成新的功能板块 切换到mater分支后我们就可以去合并我们新的分支
```shell
$ git merge new-branch
```
在完成新的功能后如果没有什么需要修复更改的我们就可以去删除这个分支
```shell
$ git branch -d new-branch
```

### Git合并冲突
我们在合并其他分支时很有可能会同时修改了同一段代码 这样两个分支的代码片段不一致 这样就会产生合并冲突

当我们去合并新分支时
```shell
$ git merge new-branch
```
会给出一个冲突提示 我们可以查看一下冲突的具体情况 如发生冲突在`test.txt`文件中
```shell
$ git diff test.txt
```
我们就可以看到冲突的具体的情况 而我们需要去手动解决这些冲突 因为两个分支的片段取舍完全取决于我们

修改完冲突之后 我们再去提交推送就可以了

顺便说一下的就是`git reset --soft xxx`和`git reset --hard xxx`的区别

> xxx是`git log`显示的每条提交记录的hash值
> 其中soft和hard的区别就是一个会撤销提交记录 而另一个不仅会撤销提交记录代码数据也会退回到之前的时间点

### git stash解决修复Bug
还是这个前提 当你正在专注于功能的开发时 有人突然告诉你要你去修改上线的`Bug`而这个`Bug`可能和你正在开发的其他模块相关

Oh No~ 又是这个问题 好吧`git stash`就可以将我们目前的工作区域暂存起来 这样我们就可以去做其他事 比如去修复下蛋疼的`Bug`

这个我们还是去创建一个新的分支去开发新的功能模块

> 这个和我们之前有所不同的是 如果新的分支的内容没有`commit` 他是会影响到`master`分支的

我们可以试着在新的分支里去写一些新的代码块 然后我们切换到matser分支 这个时候我们`git status`去看一下`git`当前的状态

我们会发现 我们是可以看到在新的分支里面的文件还没有添加到缓存区这样的信息的

所以我们还是切换到新的分支 去执行
```shell
$ git stash
```
这个时候我们可以在新的分支里去查看一下当前的状态
```shell
$ git status
```
我们会发现这里是没有需要`commit`的内容的 我们再回到`mater`分支 我们再次执行
```shell
$ git status
```
我们发现也看不到需要提交的内容 这个看起来是不是正是我们所需要的结果

这个时候我们就可以在`matser`分支里做我们想做的事 比如去修复一下需要修改的`Bug`

修复完后 我们还得去新的分支继续我们的工作 我们需要去拿回我们之前`stash`的内容

> 这个理解起来大概就是你正在办公桌忙着今天的工作 突然经理过来有给你一个新的紧急任务 没办法 这个任务十分紧急
>
> 你还是得马上去处理 所以我们只得把手上的工作先放到一边 先把经理交给我们的事先解决 解决完成之后
>
> 好嘛 今天的工作还没做完 我们又得重新拿起今天的工作任务再拿过来开始做

当然在拿回我们今天的工作任务时 会有和`git stash`相反的操作 就是`git stash apply`和`git stash pop`

这两者之间的区别就是我们可以通过执行
```shell
$ git stash list
```
当然如果是`git stash apply` 我们是可以看到stash的一条记录 这条记录包含了一个stash id标记着每条stash记录

但是如果是执行`git stash pop`的话不仅会拿回我们`stash`的数据 还会将这条`stash`记录删除

> 这个有点像**数据结构**里面的栈的`top`和`pop`的区别 一个是只是返回数据 一个不仅返回数据而且会删除掉栈顶元素
> 哈哈 这样理解起来还是可以接受的吧 :satisfied:

当然如果你只是执行`git stash apply`后想删除掉那条`stash`记录的话 我们去`drop`掉那条记录
```shell
$ git stash drop
```

所以这个时候你去执行`git stash list`是看不到之前的那条记录的

### git rebase的应用
首先我们在master分支里去`git add`提交下信息然后去生成一个新的分支
```shell
$ git checkout -b new-branch
```
我们在切换到新的分支后 我们去执行
```shell
$ git log
```
这样的话我们是可以看到在master上的提交信息的 如果这个时候我们在新的分支上修改和增加代码

我们去提交后 我们再次`git log`这样一来我们会多出一条信息

切换到`master`分支 我们像往常一样`merge`新的分支 再去执行`git log`

我们会看到会多出一条`merge`的信息 这实际上是因为我们在中途新增加了一条新的分支 所以我们才会有这么一条`merge`信息

往往团队成员多的时候 我们想整个开发过程就像在一条历史线上 每一个`commit`都在一个时间轴上 这样也可以保证了提交记录的整洁

### git 发布版本
我们正开发第三方插件供别人使用时 我们可能过程在别人提出的issue后对扩展包进行改进或者功能的增加 那么我们会针对过程发布应用
包的版本也就是`tag`

我们在执行`git push`后将自己的代码提交到仓库 这个时候我们的代码已经可以使用 难么我们可以就可以为现在的代码提供一个版本也就是打上一个标签

在`push`完成之后 我们再去执行:
```shell
$ git tag 1.0 -a
```
执行完毕后会我们就可以在vim里去写我们这次的`commit message`(发布说明) 添加完毕之后再去执行:
```shell
$ git push --tags
```
这样一来我们就把我们这次的版本推送上去了 也就是**1.0**的版本 后期再有改善的话还是这样 这样就很清楚这个扩展包的还是生命流程

如果需要删除一个`tag`的话 我们需要将本地和远程的`tag`都删除掉
首先我们可以查看一下本地当前分支的`tag`情况
```shell
$ git tag
```
接着如果我们需要删除其中的一个1.0的tag时
```shell
$ git tag -d 1.0
```
删除远程的`tag`的话(可以理解为推送一个空的`tag`):
```shell
$  git push origin --delete tag 1.0
```
这样我们就删除了`tag`为**1.0**的这个分支了

必要时也可以去选择适应哪一个版本的包